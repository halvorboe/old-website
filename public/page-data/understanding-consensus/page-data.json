{
  "componentChunkName": "component---src-templates-post-template-js",
  "path": "/understanding-consensus/",
  "result": {
    "data": {
      "site": { "siteMetadata": { "title": "Complex Codes" } },
      "markdownRemark": {
        "id": "3e70e6e5-b1e1-51e1-a91e-03c7b6fc67fa",
        "excerpt": "Imagine you are a general trying to coordinate an attack together with another friendly general. The only way to win the battle is if both attack at the same time. Both of you have a radio transmitter that can transmit and receive morse code. The transmitter runs of battery, so you cannot keep it on all the time. How do you coordinate the attack? The answer is: Because any message might be lost…",
        "html": "<!--\n\nGetting humans to agree on what's right or wrong is really hard. Making machines agree is should be much easier - in theory. That is until you realize that a machine can die at any time, can loose its ability to speak and so on. In this blog post I'll go throught the paper called \"Paxos vs Raft: Have we reached consensus on distributed consensus?\" and try to explain what the different algorithms do.\n\n\nPaper\n\nAbstract\n- Consensus is critical\n- Two main algorithms\n    - Paxos\n    - Raft\n- Raft is simpler\n\nIntroduction\n- State machine replication\n    - Paxos is the defecto algorithm -> hard to understand\n- Raft is simpler whilst being as efficient\n- Reft\n    - Presentation\n        - Pragmatic\n    - Simplicity\n        - Simlicity over performance\n    - Underlying algorithm\n        - Novel approach to lear election\n- Paxos is a family of algorithms\n    - Chubby\n- No difference in understandability\n\nBackground\n-\n\n-->\n<p>Imagine you are a general trying to coordinate an attack together with another friendly general. The only way to win the battle is if both attack at the same time. Both of you have a radio transmitter that can transmit and receive morse code. The transmitter runs of battery, so you cannot keep it on all the time. How do you coordinate the attack?</p>\n<p>The answer is: Because any message might be lost, there is no way to coordinate the attack with complete certainty.</p>\n<p>You have probably read about that problem before somewhere. The problem might seem staged, but when it comes to computers, it is a real issue. A real issue that has been solved by TCP/IP. In this article, I try to explain the two most popular algorithms for distributed consensus - Paxos and Raft. They solve a similar issue:</p>\n<p>You have a cluster of <em>n</em> servers. Each of the servers might fail at any time. A constant flow of random messages hits each of the servers. How do you make the cluster agree on what messages are received and in what order?</p>\n<p>The short answer is: It is complicated.</p>\n<p>The long answer is:</p>\n<h2>What are Distributed-State-Machines?</h2>\n<p>As mentioned above, there are two main algorithms for reaching consensus in a distributed system.</p>\n<p>Before we get to explaining the algorithms, let us look into what reaching consensus in a distributed system means. To understand what that means, it is useful to understand what a state machine is. A state machine is a system that stores a state, and given an action goes to another state. What consensus in a distributed system means is that we are able to treat a system of multiple machines as a state machine. That is useful for programmers because they do not have to think about the distributed nature of the system.</p>\n<h2>How about giving machines roles?</h2>\n<p>Ok, so we are trying to create a distributed state machine. First, consider a system with a single machine. We send a message to the machine and it stores them in the same order as they were received. That machine is the leader.</p>\n<h3>Leader</h3>\n<p>The leader is the machine that receives all the messages. If we only have a single machine, and call that machine the leader it might not be a distributed system, but it gets the basic point across.</p>\n<h3>Followers</h3>\n<p>When we have the leader we need more machines in the system. We’ll call the machines followers. They also store the state of the system and will check if the leader is alive.</p>\n<p>If they suspect the leader is dead they will try to become the leader.</p>\n<h3>Candidate</h3>\n<p>That is a machine that is trying to become the new leader. For it to become the leader, all the other machines have to agree that it is the leader.</p>\n<h2>So what does the lifecycle look like?</h2>\n<p>With these roles in place, we have set the play for a lifecycle. Firstly, let us assume all the machines are followers. The machines will then realize there is not a leader and elect a leader.</p>\n<ol>\n<li>A machine becomes the leader</li>\n<li>Messages are received by the leader</li>\n<li>The leader dies</li>\n<li>Repeat…</li>\n</ol>\n<p>You now hopefully understand how the algorithms work.</p>\n<h2>Where do Paxos and Raft differ?</h2>\n<p>In leader election.</p>\n<p>Paxos requires the leader to be up to date.</p>\n<p>Raft fetches the messages from the other state machines.</p>\n<p>-</p>",
        "frontmatter": {
          "title": "Understanding Algorithms for Distributed Consensus",
          "date": "May 02, 2020",
          "description": "",
          "draft": true
        }
      }
    },
    "pageContext": {
      "slug": "/understanding-consensus/",
      "previous": {
        "fields": { "slug": "/tldr-bigtable/" },
        "frontmatter": { "title": "TL;DR - Bigtable" }
      },
      "next": null
    }
  }
}
